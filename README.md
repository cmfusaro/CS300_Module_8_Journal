# CS300_Module_8_Journal
Projects 1 and 2

The first project for this course was to use pseudo code to implement three different data structures and use them to store 
objects that were created from a text file and then print them back out. In doing this, I assumed the data was unsorted and
would nullify the time efficiencies of the different data structures. I was wrong. With unsorted data, a binary search tree 
would be the most efficient followed by hash tables and vectors. The second project was implementing the pseudo-code for one
of these data structures. The structure I chose was the binary search tree. It was the most efficient and essential for me 
to truly understand its inner workings and how to implement it into code. I used some sample code in a previous assignment 
and reworked it to fit my use case. As I don't see myself as a true C++ practitioner, I needed some inspiration to work from. 
It seemed like a great help because I wasn't expecting to create something from a loosely understood idea. I was taking a 
problem, breaking it down, and using a new concept to improve it. As much as this may sound like a mincing of words, this 
perspective on the objective made it all the more attainable for me. The takeaway for me on this was to understand that there
are many ways to accomplish the same goal and based on resources and other restraints may dictate using a different means to
accomplish the same task.

Many obstacles had to be overcome in this course for me. I found that staying vigilant and leaning on the proper
support helped me get through this course. As always, Google and YouTube played an invaluable part in helping me find examples to 
draw inspiration from. I liked to think of myself as an intermediate Python developer, and this experience has opened my eyes to 
blind spots that weren't apparent to me then. It has intrigued me to expand my knowledge in these areas. One of the key 
improvements to my coding style that I can attribute to this project is smaller, more narrow functions. I know that I have tried 
to do too much at one time. This made my code harder to understand and less than ideal for maintainability. Testing bloated 
functions would make the test unreliable and decrease its effectiveness as an indicator of whether the code was still pointed 
toward the proper end result. 
